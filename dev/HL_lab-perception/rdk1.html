<!DOCTYPE html>
<!--
continuous random-dot kinetogram, with signal to the right
need to have fullscreen.js in the same directory
-->
<html>
<head>

<script src="fullscreen.js"></script>

<script>

// uses a reference frame in which the origin is at the center, height is 2 (positive is up),
// and width is proportional

width_pix = 500;		// not real pixels, logical pixels (window height about 600 at any resolution)
height_pix = 500;
n_dots = 100;
signal_fraction = 0.25;
speed = 0.05;			// distance units/sec, where 2 distance units = stimulus height, and frame rate assumed to be 60 Hz
lifetime_frames = 12;	// in refresh calls, where usually 1 refresh call = 1 monitor refresh
dot_radius = 0.01;		// distance units
fp_radius = 0.02;		// distance units
pause_duration = 0.5;	// seconds
stimulus_color = "rgb(0, 0, 0)";
fp_color = "rgb(255, 0, 0)";
frame_rate = 60;		// assumed frame rate for distance calculation

function get_time()
{
	return (new Date()).getTime()/1000.0;
}

function polar2cart(r, theta)
{
	return [r*Math.cos(theta), r*Math.sin(theta)];
}

// returns random position inside unit disk, with uniform distribution
function random_position()
{
	var r = Math.sqrt(Math.random());
	var theta = 2*Math.PI*Math.random();
	return polar2cart(r, theta);
}

function center(elem)
{
	elem.style.padding = "0px";
	elem.style.margin = "auto";
	elem.style.display = "block";
	elem.style.position = "absolute";
	elem.style.top = elem.style.bottom = elem.style.left = elem.style.right = "0px";
}

window.onload = function()
{
	state = "create button";
	update();
};

function update()
{
	if(state == "create button") {
		button = document.createElement("button");
		button.style.width = "100px";	// note that to set size of button,
		button.style.height = "40px";	// you use button.style.width/height
		center(button);
		button.appendChild(document.createTextNode("Start"));
		button.onclick = function() { state = "button clicked"; };
		document.body.appendChild(button);
		state = "wait for button";
	}
	else if(state == "button clicked") {
		document.body.removeChild(button);
		document.documentElement.requestFullscreen();
		
		canvas = document.createElement("canvas");		// create canvas for stimulus
		canvas.width = window.devicePixelRatio*width_pix;		// the next four lines set the size and resolution
		canvas.height = window.devicePixelRatio*height_pix;		// the canvas; you need to scale .width and .height by
		canvas.style.width = width_pix + "px";					// window.devicePixelRatio to get high resolution on
		canvas.style.height = height_pix + "px";				// high pixel density monitors, but NOT .style.width/height
		center(canvas);
		var context = canvas.getContext("2d");
		// the next two transformations set a reference frame where (0, 0) is at the center of the canvas,
		// (0, +1) is at the top on in the middle and (0, -1) at the bottom in the middle, so the height is 2
		// (+1, 0) is at the same distance from the center but to the right, etc.
		context.translate(window.devicePixelRatio*width_pix/2, window.devicePixelRatio*height_pix/2);
		context.scale(window.devicePixelRatio*height_pix/2, -window.devicePixelRatio*height_pix/2);
		height = 2.0;
		width = (width_pix/height_pix)*height;
		document.body.appendChild(canvas);
		
		var n_signal_dots = Math.round(signal_fraction*n_dots);		// initial dots
		var n_noise_dots = n_dots - n_signal_dots;
		dots = new Array(n_dots);
		for(var i = 0; i < n_dots; i++) {
			var ang = (i < n_signal_dots ? 0 : 2*Math.PI*(i - n_signal_dots)/n_signal_dots);
			dots[i] = {pos0: random_position(),
					   vel: polar2cart(speed, ang),
					   frame: Math.floor(Math.random()*lifetime_frames)};
		}
		t0 = get_time();
		n_frames = 0;
		fps_text = document.createElement("div");
		document.body.appendChild(fps_text);
		state = "pause";
	}
	else if(state == "pause") {		// some extra time before starting stimulus
		if(get_time() > t0 + pause_duration) {
			t0 = get_time();
			state = "motion";
		}
	}
	else if(state == "motion") {	// display continuous RDK
		var context = canvas.getContext("2d");
		context.clearRect(-width/2, -height/2, width, height);
		context.fillStyle = stimulus_color;
		for(var i = 0; i < n_dots; i++) {
			if(dots[i].frame >= lifetime_frames - 1) {	// if dot at the end of its lifetime, renew position
				dots[i].frame = 0;
				dots[i].pos0 = random_position();
			}
			var pos = dots[i].pos0;		// calculate current position
			var t_dot = dots[i].frame/frame_rate;
			for(var d = 0; d < 2; d++)
				pos[d] += dots[i].vel[d]*t_dot;
			if(pos[0]*pos[0] + pos[1]*pos[1] < 1) {		// display if inside unit disk
				context.beginPath();
				context.arc(pos[0], pos[1], dot_radius, 0, 2*Math.PI);
				context.fill();
			}
			dots[i].frame++;		// in any case update frames for finite lifetime
		}
		context.fillStyle = fp_color;	// draw FP
		context.beginPath();
		context.arc(0, 0, fp_radius, 0, 2*Math.PI);
		context.fill();
		n_frames++;					// display FPS occasionally
		if(n_frames%60 == 0)
			fps_text.innerHTML = "" + (n_frames/(get_time() - t0)).toFixed(2) + " fps";
	}
	requestAnimationFrame(update);	// will call update on next frame (usually)
}

</script>
</head>
<body></body>
</html>
